/*
 * Copyright (c) 2021. 贝壳找房（北京）科技有限公司
 */
package suanFaModel.DpCode;

/**
 * https://zhuanlan.zhihu.com/p/92288604
 * @author xiaokuo
 * @since 2021/2/7 3:23 下午
 */
public class Dp5ThrowEggs {

    public static void main(String[] args) {
        Dp5ThrowEggs cl = new Dp5ThrowEggs();
        System.out.println(cl.superEggDrop(1,2));
    }

    /**
     * 887 输入：K = 1, N = 2
     * //输出：2
     * 解释： //鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
     * //否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
     * //如果它没碎，那么我们肯定知道 F = 2 。
     * //因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
     */
    public int superEggDrop(int K, int N) {

        if (N == 0) {
            return 0;
        }

        int[][] dp = new int[K + 1][N + 1];

        //k个鸡蛋  0层楼
        for (int i = 1; i <= K; i++) {
            dp[i][0] = 0;
        }

        //0个鸡蛋  N层楼
        for (int j = 1; j <= N; j++) {
            dp[0][j] = 0;
        }

        dp[0][0] = 0;

//  dp[k][m] = n
//# 当前有 k 个鸡蛋，可以尝试扔 m 次鸡蛋
//# 这个状态下，最坏情况下最多能确切测试一栋 n 层的楼
        int m = 0;
        while (dp[K][m] < N) {
            m++;
            for (int i = 1; i <= K; i++) {
                //当前碎  K-1，剩余楼层 i - 1。那么鸡蛋的个数 K 应该减一，搜索的楼层区间应该从 [1..N] 变为 [1..i-1] 共 i-1 层楼；
//                //没碎  k    剩余N - i。  那么鸡蛋的个数 K 不变，搜索的楼层区间应该从 [1..N] 变为 [i+1..N] 共 N-i 层楼。
//                1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上。
//                2、无论你上楼还是下楼，总的楼层数 = 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）。
//                根据这个特点，可以写出下面的状态转移方程：
//                dp[i][m] = dp[i][m - 1] + dp[i - 1][m - 1] + 1
//                dp[i][m - 1] 就是楼上的楼层数，因为鸡蛋个数 i 不变，也就是鸡蛋没碎，扔鸡蛋次数 m 减一；
//                dp[i - 1][m - 1] 就是楼下的楼层数，因为鸡蛋个数 i 减一，也就是鸡蛋碎了，同时扔鸡蛋次数 m 减一。
//                PS：这个 m 为什么要减一而不是加一？之前定义得很清楚，这个 m 是一个允许的次数上界，而不是扔了几次。

                dp[i][m] = dp[i - 1][m-1] + dp[i][m-1] + 1;
//                dp[k][m - 1] 就是楼上的楼层数，因为鸡蛋个数 k 不变，也就是鸡蛋没碎，扔鸡蛋次数 m 减一；
//                dp[k - 1][m - 1] 就是楼下的楼层数，因为鸡蛋个数 k 减一，也就是鸡蛋碎了，同时扔鸡蛋次数 m 减一。
            }
        }
        return m;
    }
}
